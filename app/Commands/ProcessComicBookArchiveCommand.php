<?php namespace App\Commands;

use App\User;
use App\ComicBookArchive;
use App\Upload;
use App\Comic;
use App\Series;
use App\ComicImage;
use App\Commands\Command;

use Illuminate\Queue\SerializesModels;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Contracts\Queue\ShouldBeQueued;

use Illuminate\Contracts\Bus\SelfHandling;

use Log;
use Storage;

use ZipArchive;
use RarArchive;

use Rhumsaa\Uuid\Uuid;

class ProcessComicBookArchiveCommand extends Command implements ShouldBeQueued, SelfHandling
{

    use InteractsWithQueue, SerializesModels;

    protected $message;
    protected $user_id;
    protected $cba_id;
    protected $comic_id;


    /**
     * Create a new command instance.
     *
     * @return void
     */
    public function __construct($message){
        $this->message = $message;
    }
    /**
     *
     */
    public function handle(){
        $process_info = $this->message;
        $this->user_id = $process_info['user_id'];
        $process_archive = false;

        $cba = ComicBookArchive::where('comic_book_archive_hash', '=', $process_info['hash'])->first();

        if (!$cba){
            $cba = $this->createComicBookArchive();
            $process_archive = true;
        }
        $this->cba_id = $cba->id;

        $comic_info = $this->getComicInfo($process_info['upload_id']);

        $comic_info['comic_book_archive_id'] = $cba->id;

        $comic = $this->createComic($comic_info);
        $this->comic_id = $comic->id;


        if($process_archive){
            $this->processArchive($process_info['upload_id']);
        }
    }

    /**
     * @return ComicBookArchive
     */
    private function createComicBookArchive(){
        $process_info = $this->message;

        $cba = new ComicBookArchive();
        $cba->upload_id = $process_info['upload_id'];
        $cba->comic_book_archive_hash = $process_info['hash'];
        $cba->comic_book_archive_status = 0;
        $cba->save();

        return $cba;
    }

    /**
     * @param $comic_info
     * @return Comic
     */
    private function createComic($comic_info){

        $cba = ComicBookArchive::findOrFail($comic_info['comic_book_archive_id']);

        $newComicID = $comic_info['comic_id'];//TODO:Reconsider Client ID Generation //(Comic::find($comic_info['comic_id']) ? str_random(40) : $comic_info['comic_id']);//If ID generated by client already exists, generate a new one

        $comic = new Comic;
        $comic->id = $newComicID;
        $comic->comic_issue = $comic_info['comic_issue'];
        $comic->comic_writer = $comic_info['comic_writer'];
        $comic->comic_book_archive_contents = (($cba->comic_book_archive_contents ? $cba->comic_book_archive_contents : ''));
        $comic->user_id = $this->user_id;
        $comic->series_id = $comic_info['series_id'];
        $comic->comic_book_archive_id = $cba->id;
        $comic->comic_status = $cba->comic_book_archive_status;
        $comic->save();

        return $comic;
    }

    /**
     * @param $match_data
     * @return Series
     */
    private function createSeries($match_data){

        $series = new Series;
        $newSeriesID = $match_data['series_id'];//TODO:Reconsider Client ID Generation //(Series::find($match_data['series_id']) ? str_random(40) : $match_data['series_id']);//If ID generated by client already exists, generate a new one

        $series->id = $newSeriesID;
        $series->series_title = $match_data['series_title'];
        $series->series_start_year = $match_data['series_start_year'];
        $series->series_publisher = 'Unknown';
        $series->user_id = $this->user_id;
        $series->save();

        return $series;
    }

    /**
     * @param $upload_id
     * @return array
     */
    private function getComicInfo($upload_id){//Never Fails only returns empty

        $upload = Upload::findOrFail($upload_id);//TODO: Decide on find of find or fail

        $match_data = json_decode($upload->match_data, true);

        $series_id = $this->getSeriesInfo($match_data);

        return $comicInfo = [
            'comic_issue' => $match_data['comic_issue'],
            'comic_id' => $match_data['comic_id'],
            'series_id' => $series_id,
            'comic_writer' => 'Unknown'
        ];

    }

    /**
     * @param $match_data
     * @return mixed
     */
    private function getSeriesInfo($match_data){

        $series = User::find($this->user_id)->first()->series()->find($match_data['series_id']);

        if($match_data['exists'] || !$match_data['exists'] && !$series){//create
            $series = $this->createSeries($match_data);
        }

        return $series->id;


    }

    private function processArchive($upload_id){
        $upload_obj = Upload::find($upload_id);
        $user_uploads = Storage::disk(env('user_uploads'));

        //download archive
        if($user_uploads->exists($upload_obj->file_upload_name)){
            $cba_file_name = $user_uploads->get($upload_obj->file_upload_name);
            $archive_extract_area = $upload_obj->file_random_upload_id.'/archive/'.$upload_obj->file_upload_name;
            $cba_extract_area = Storage::disk('cba_extraction_area');
            $cba_extract_area->put($archive_extract_area, $cba_file_name);
            $cba_extract_area->makeDirectory($upload_obj->file_random_upload_id.'/images/');

            $comic_json = $this->extractArchive($upload_obj);

        }else{
            //TODO: Report File Not Found
        }

    }

    private function extractArchive($upload_obj){
        //TODO: Support nested archives.

        $cba_extract_area = Storage::disk('cba_extraction_area')->getDriver()->getAdapter()->getPathPrefix();
        $archive = $cba_extract_area.'/'.$upload_obj->file_random_upload_id.'/archive/'.$upload_obj->file_upload_name;
        $images = $cba_extract_area.'/'.$upload_obj->file_random_upload_id.'/images';

        $pages = [];

        if(Storage::disk('cba_extraction_area')->exists($upload_obj->file_random_upload_id)){//check if extraction zone exists

            if(in_array($upload_obj->file_original_file_type, array('zip', 'cbz'))) {

                $zip = new ZipArchive;

                if ($zip->open($archive) === true) {

                    if(!$zip->numFiles){//if zip is empty
                        //TODO: Fail out and Report empty zip.
                    }

                    for ($i = 0; $i < $zip->numFiles; $i++) {

                        $entry = $zip->getNameIndex($i);

                        $entryExt = strtolower(pathinfo(basename($entry), PATHINFO_EXTENSION));//Get Extension
                        $acceptedExtensions = ['jpg', 'jpeg'];

                        if (substr($entry, -1) == '/') continue; // skip directories
                        if (!in_array($entryExt, $acceptedExtensions)) continue; //skip non-jpegs

                        $file = basename($entry);
                        $zip->extractTo($images, array($entry));

                        $image_slug = $this->processImage($images . "/" . $file);
                        $pages[$image_slug] = $file;

                    }
                    $zip->close();
                    //TODO: Delete zip and extracted files

                }else{
                    //TODO: Fail out and report zip could not be opened
                }

            }

            else if(in_array($upload_obj->file_original_file_type, array('rar', 'cbr'))){

                $rar = RarArchive::open($archive);

                if (!$rar === false) {//rar archive doesn't like truth

                    if(!count($rar->getEntries())){
                        //TODO: Fail out and report empty rar
                    }

                    foreach ($rar->getEntries() as $key => $entry) {

                        $entryExt = strtolower(pathinfo(basename($entry->getName()), PATHINFO_EXTENSION));
                        $acceptedExtensions = ['jpg', 'jpeg'];

                        if (substr($entry, -1) == '/') continue; // skip directories
                        if (!in_array($entryExt, $acceptedExtensions)) continue; //skip non-jpegs

                        $file = basename($entry->getName());

                        $entry->extract( false , $images.'/'.$file);

                        $image_slug = $this->processImage($images."/".$file);
                        $pages[$image_slug] = $file;
                    }

                    $rar->close();
                    //TODO: Delete rar and extracted files

                }else{
                    //TODO: Fail out and report rar could not be opened
                }

            }

            else{
                //TODO: Report not a valid archive. All though this shouldn't happen at this point.
            }

            if(!$pages) {
                //TODO: If pages array is empty something has gone very wrong. Fail out and report this. most likely a nested directory issue.
            }

            natsort($pages);
            $pages = array_flip($pages);
            $pages = array_values($pages);

            array_unshift($pages, 'presentation_value');
            unset($pages[0]);//Add and remove value at zero to shift array to 1. Just for presentation.


            $cba= ComicBookArchive::find($this->cba_id);
            $cba->comic_book_archive_contents = json_encode($pages, JSON_FORCE_OBJECT);
            $cba->comic_book_archive_status = 1;
            $cba->save();

            $comic = Comic::find($this->comic_id);
            $comic->comic_book_archive_contents = json_encode($pages, JSON_FORCE_OBJECT);
            $comic->comic_status = 1;
            $comic->save();

            return $pages;

        }
        else{
            //TODO: Report Extraction zone not found
        }
    }

    private function processImage($image){

        $fileHash = hash_file('md5', $image);

        $imageentry = ComicImage::where('image_hash', '=', $fileHash)->first();


        if(!$imageentry){

            $imageExt = strtolower(pathinfo($image, PATHINFO_EXTENSION));


            $image_slug = Uuid::uuid4()->toString();

            Storage::disk(env('user_images'))->put($image_slug.".".$imageExt, file_get_contents($image));

            $imageentry = new ComicImage;

            $imageentry->image_slug = $image_slug;
            $imageentry->image_hash = $fileHash;
            $imageentry->image_size = filesize($image);
            $imageentry->save();

        }
        $imageentry->comicBookArchives()->attach($this->cba_id);

        return $imageentry->image_slug;

    }

    /**
     * Handle a job failure.
     *
     * @return void
     */
    public function failed()
    {
        // TODO: Write failure action
    }

}
